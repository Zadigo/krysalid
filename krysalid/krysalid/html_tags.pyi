from functools import total_ordering
from typing import Any, Generator, List, Literal, Optional

from krysalid.compiler import Compiler


class NavigationMixin:
    def find_all_next(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_all_previous(self, name: str = Optional[None]): ...
    def find_next(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_previous(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_next_sibling(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_previous_sibling(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_next_siblings(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_previous_siblings(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_parent(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def find_parents(self, name: str = Optional[None], attrs: dict = Optional[dict]): ...
    def get_attribute_list(self, key: str, default = Optional[list]): ...
    def get_text(self, seperator: str = Optional[None], clean: bool = Optional[True]): ...


class BaseTag(NavigationMixin):
    coordinates: list = ...
    compiler: Compiler = ...
    closing_tag: bool = ...
    is_string = ...
    index: str = ...
    limits: List[int, int] = ...
    name: str = ...
    _attrs: list = ...
    def __init__(self, name: str, attrs: list[tuple[str, str, list, tuple]], coordinates: list[int]) -> None: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def attrs_as_string(self) -> Generator: ...


class Tag(BaseTag): ...


@total_ordering
class StringMixin:
    is_string: Literal[True] = ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, value: Any) -> bool: ...
    def __gt__(self, value: Any) -> bool: ...
    def __len__(self, value: Any) -> bool: ...
    def __contains__(self, value: Any) -> bool: ...
    @property
    def attrs(self) -> dict: ...
    def has_attr(self, name: str) -> bool: ...


class Comment(StringMixin, BaseTag):
    data: str = ...
    def __init__(self, data: str): ...


class NewLine(StringMixin, BaseTag):
    def __init__(self, data=Literal['\n']) -> None: ...


class ElementData(StringMixin, BaseTag):
    def __init__(self, data: str) -> None: ...
